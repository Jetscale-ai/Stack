name: Reusable Chart Release (OCI)

on:
  workflow_call:
    inputs:
      chart_path:
        required: true
        type: string
        description: "Path to the chart directory (e.g. charts/backend-api)"
      image_name:
        required: false
        type: string
        description: "Optional override for artifacts (usually derived from Chart.yaml)"
    secrets:
      token:
        required: true
        description: "GitHub Token with packages:write permissions"

jobs:
  release:
    runs-on: ubuntu-latest
    # âœ… ETHOS: Standardize on the Booster Toolchain
    container:
      image: ghcr.io/jetscale-ai/booster-dev:latest
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.token }}

    steps:
      - name: Checkout Source
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 1. Semantic Release
      # Calculates version based on the CALLER's git history
      - name: Semantic Release
        id: semrel
        uses: go-semantic-release/action@v1
        with:
          github-token: ${{ secrets.token }}
          allow-initial-development-versions: true
          force-bump-patch-version: true

      # 2. Package & Push
      - name: Publish Chart
        if: steps.semrel.outputs.version != ''
        working-directory: ${{ inputs.chart_path }}
        env:
          VERSION: ${{ steps.semrel.outputs.version }}
          REGISTRY: ghcr.io
          REPO_OWNER: ${{ github.repository_owner }}
        run: |
          echo "ðŸš€ Publishing Version: $VERSION"

          # A. Login to GHCR (Helm OCI)
          echo "${{ secrets.token }}" | helm registry login ${REGISTRY} --username ${{ github.actor }} --password-stdin

          # B. Inject Version into Chart.yaml
          # We use yq (pre-installed in booster-dev)
          yq -i ".version = \"${VERSION}\"" Chart.yaml
          yq -i ".appVersion = \"${VERSION}\"" Chart.yaml

          # C. Build Dependencies
          # Safe to run even if no dependencies exist.
          # Note: If this chart depends on others, they must be accessible via OCI or public repo.
          helm dependency build

          # D. Package
          helm package .

          # E. Push to OCI
          # helm push output is like: "Pushed: ghcr.io/owner/charts/my-chart:1.2.3"
          helm push *.tgz oci://${REGISTRY}/${REPO_OWNER}/charts
