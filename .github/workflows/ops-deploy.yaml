name: Manual Helm Deploy

on:
  workflow_dispatch:
    inputs:
      environment_type:
        description: 'Environment type (staging, live)'
        required: true
        default: staging
        type: choice
        options:
          - staging
          - live
      client_name:
        description: 'Client name (e.g., jetscale, console)'
        required: true
        default: jetscale
        type: string
      cloud_provider:
        description: 'Cloud provider'
        required: true
        type: choice
        default: 'aws'
        options:
          - aws
      aws_region:
        description: 'Client/Cluster AWS Region'
        required: true
        type: choice
        default: 'us-east-1'
        options:
          - us-east-1
          - us-west-2
          - eu-west-1
      build_images:
        description: 'Build new images from branch code'
        required: false
        type: boolean
        default: false
      backend_ref:
        description: 'Backend repo branch/tag (required if build_images=true)'
        required: false
        type: string
        default: 'main'
      frontend_ref:
        description: 'Frontend repo branch/tag (required if build_images=true)'
        required: false
        type: string
        default: 'main'

# Required for OIDC
permissions:
  id-token: write
  contents: read

jobs:
  # ============================================================================
  # BUILD IMAGES (Optional - only if build_images=true)
  # ============================================================================
  build-images:
    name: Build Images
    if: inputs.build_images == true
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment_type }}-${{ inputs.client_name }}
    outputs:
      backend_tag: ${{ steps.build.outputs.backend_tag }}
      frontend_tag: ${{ steps.build.outputs.frontend_tag }}
    steps:
      - name: Configure AWS Credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/${{ inputs.client_name }}-${{ inputs.environment_type }}-github-actions-role
          aws-region: ${{ inputs.aws_region }}
          role-session-name: github-actions-build-images

      - name: Login to ECR
        id: ecr-login
        uses: aws-actions/amazon-ecr-login@v2

      - name: Checkout Backend
        uses: actions/checkout@v4
        with:
          repository: Jetscale-ai/Backend
          ref: ${{ inputs.backend_ref }}
          token: ${{ secrets.JETSCALEBOT_GITHUB_TOKEN }}
          path: backend

      - name: Checkout Frontend
        uses: actions/checkout@v4
        with:
          repository: Jetscale-ai/Frontend
          ref: ${{ inputs.frontend_ref }}
          token: ${{ secrets.JETSCALEBOT_GITHUB_TOKEN }}
          path: frontend

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and Push Images
        id: build
        env:
          ECR_REGISTRY: ${{ steps.ecr-login.outputs.registry }}
          CLIENT: ${{ inputs.client_name }}
          ENV_TYPE: ${{ inputs.environment_type }}
        run: |
          # Generate image tag
          TIMESTAMP=$(date -u +"%Y%m%d-%H%M%S")
          BACKEND_SHA=$(cd backend && git rev-parse --short HEAD)
          FRONTEND_SHA=$(cd frontend && git rev-parse --short HEAD)

          BACKEND_TAG="${ENV_TYPE}-${CLIENT}-${TIMESTAMP}-${BACKEND_SHA}"
          FRONTEND_TAG="${ENV_TYPE}-${CLIENT}-${TIMESTAMP}-${FRONTEND_SHA}"

          BACKEND_REPO="${ECR_REGISTRY}/${CLIENT}-${ENV_TYPE}-backend"
          FRONTEND_REPO="${ECR_REGISTRY}/${CLIENT}-${ENV_TYPE}-frontend"

          echo "üî® Building backend image: ${BACKEND_REPO}:${BACKEND_TAG}"
          docker buildx build \
            --platform linux/amd64 \
            --push \
            -t "${BACKEND_REPO}:${BACKEND_TAG}" \
            ./backend

          echo "üî® Building frontend image: ${FRONTEND_REPO}:${FRONTEND_TAG}"
          docker buildx build \
            --platform linux/amd64 \
            --push \
            -t "${FRONTEND_REPO}:${FRONTEND_TAG}" \
            ./frontend

          echo "backend_tag=${BACKEND_TAG}" >> $GITHUB_OUTPUT
          echo "frontend_tag=${FRONTEND_TAG}" >> $GITHUB_OUTPUT

          echo "‚úÖ Images built and pushed:"
          echo "  Backend:  ${BACKEND_REPO}:${BACKEND_TAG}"
          echo "  Frontend: ${FRONTEND_REPO}:${FRONTEND_TAG}"

  # ============================================================================
  # VALIDATE CONFIGURATION
  # ============================================================================
  validate:
    name: "Ops: Validate Config"
    runs-on: ubuntu-latest
    outputs:
      values_files: ${{ steps.build_values.outputs.files }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build values file list
        id: build_values
        run: |
          # Build the list of values files based on the tiered structure
          # Order: base -> cloud provider -> environment defaults -> client-specific
          
          VALUES_FILES=""
          
          # 1. Cloud provider values (required)
          CLOUD_VALUES="envs/${{ inputs.cloud_provider }}.yaml"
          if [ ! -f "$CLOUD_VALUES" ]; then
            echo "‚ùå Cloud provider values file not found: $CLOUD_VALUES"
            exit 1
          fi
          VALUES_FILES="$CLOUD_VALUES"
          
          # 2. Environment defaults (optional)
          ENV_DEFAULTS="envs/${{ inputs.environment_type }}/default.yaml"
          if [ -f "$ENV_DEFAULTS" ]; then
            VALUES_FILES="$VALUES_FILES,$ENV_DEFAULTS"
          fi
          
          # 3. Client-specific values (required)
          CLIENT_VALUES="envs/${{ inputs.environment_type }}/${{ inputs.client_name }}.yaml"
          if [ ! -f "$CLIENT_VALUES" ]; then
            echo "‚ùå Client values file not found: $CLIENT_VALUES"
            exit 1
          fi
          VALUES_FILES="$VALUES_FILES,$CLIENT_VALUES"
          
          echo "files=$VALUES_FILES" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Values files to be applied (in order):"
          echo "$VALUES_FILES" | tr ',' '\n' | sed 's/^/  - /'

  helm-diff:
    name: "Ops: Helm Diff"
    needs: validate
    runs-on: ubuntu-latest
    # Use GitHub environment-type for seeing the diff (read-only role)
    environment: ${{ inputs.environment_type }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          # NOTE: This currently uses the deploy role. If we later add a read-only IAM role for diff,
          # switch this to that role (least-privilege).
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/${{ inputs.client_name }}-${{ inputs.environment_type }}-github-diff-actions-role
          aws-region: ${{ inputs.aws_region }}
          role-session-name: github-actions-helm-diff

      - name: Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: 'v3.18.3'

      - name: Install Helm Diff Plugin
        run: |
          helm plugin install https://github.com/databus23/helm-diff || true
          helm plugin list

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig \
            --region ${{ inputs.aws_region }} \
            --name ${{ inputs.client_name }}-${{ inputs.environment_type }}
          
          # Verify connection
          kubectl cluster-info
          kubectl get nodes

      - name: Login to GHCR (Helm)
        env:
          BOT_TOKEN: ${{ secrets.JETSCALEBOT_GITHUB_TOKEN }}
        run: |
          echo "$BOT_TOKEN" | helm registry login ghcr.io --username jetscalebot --password-stdin

      - name: Update Helm Dependencies
        run: |
          cd charts/jetscale
          helm dependency update

      - name: Run Helm Diff
        id: helm_diff
        run: |
          # Build values flags from comma-separated list
          VALUES_FLAGS=""
          IFS=',' read -ra FILES <<< "${{ needs.validate.outputs.values_files }}"
          for file in "${FILES[@]}"; do
            VALUES_FLAGS="$VALUES_FLAGS --values $file"
          done
          
          echo "üìä Running Helm diff..."
          echo "Release: ${{ inputs.client_name }}"
          echo "Namespace: ${{ inputs.client_name }}-${{ inputs.environment_type }}"
          echo "Values files: ${{ needs.validate.outputs.values_files }}"
          
          # Run diff and capture output
          set +e
          helm diff upgrade ${{ inputs.client_name }} ./charts/jetscale \
            --namespace ${{ inputs.client_name }}-${{ inputs.environment_type }} \
            --allow-unreleased \
            $VALUES_FLAGS \
            --context 5 \
            --color
          DIFF_EXIT_CODE=$?
          set -e
          
          # Check if there are changes
          if [ $DIFF_EXIT_CODE -eq 0 ]; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "üìã No changes detected"
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "üìã Changes detected"
          fi

      - name: Check for changes
        if: steps.helm_diff.outputs.has_changes == 'false'
        run: |
          echo "‚ö†Ô∏è No changes detected. Deployment would be a no-op."
          echo "If you expected changes, verify your values files."

  helm-deploy:
    name: "Ops: Helm Deploy"
    needs: [validate, helm-diff, build-images]
    # Always run, but build-images may be skipped
    if: always() && needs.validate.result == 'success' && needs.helm-diff.result == 'success'
    runs-on: ubuntu-latest
    # Use GitHub environment for manual approval (staging has required reviewers configured).
    environment: ${{ inputs.environment_type }}-${{ inputs.client_name }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/${{ inputs.client_name }}-${{ inputs.environment_type }}-github-actions-role
          aws-region: ${{ inputs.aws_region }}
          role-session-name: github-actions-helm-deploy

      - name: Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: 'v3.18.3'

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig \
            --region ${{ inputs.aws_region }} \
            --name ${{ inputs.client_name }}-${{ inputs.environment_type }}
          
          # Verify connection
          kubectl cluster-info

      - name: Login to GHCR (Helm)
        env:
          BOT_TOKEN: ${{ secrets.JETSCALEBOT_GITHUB_TOKEN }}
        run: |
          echo "$BOT_TOKEN" | helm registry login ghcr.io --username jetscalebot --password-stdin

      - name: Update Helm Dependencies
        run: |
          cd charts/jetscale
          helm dependency update

      - name: Deploy with Helm
        env:
          BUILD_IMAGES: ${{ inputs.build_images }}
          BACKEND_TAG: ${{ needs.build-images.outputs.backend_tag }}
          FRONTEND_TAG: ${{ needs.build-images.outputs.frontend_tag }}
          ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ inputs.aws_region }}.amazonaws.com
          CLIENT: ${{ inputs.client_name }}
          ENV_TYPE: ${{ inputs.environment_type }}
        run: |
          # Build values flags from comma-separated list
          VALUES_FLAGS=""
          IFS=',' read -ra FILES <<< "${{ needs.validate.outputs.values_files }}"
          for file in "${FILES[@]}"; do
            VALUES_FLAGS="$VALUES_FLAGS --values $file"
          done

          # Add image overrides if we built new images
          IMAGE_OVERRIDES=""
          if [ "${BUILD_IMAGES}" == "true" ] && [ -n "${BACKEND_TAG}" ] && [ -n "${FRONTEND_TAG}" ]; then
            echo "üì¶ Using freshly built images:"
            echo "  Backend:  ${BACKEND_TAG}"
            echo "  Frontend: ${FRONTEND_TAG}"

            BACKEND_REPO="${ECR_REGISTRY}/${CLIENT}-${ENV_TYPE}-backend"
            FRONTEND_REPO="${ECR_REGISTRY}/${CLIENT}-${ENV_TYPE}-frontend"

            IMAGE_OVERRIDES="--set backend-api.image.repository=${BACKEND_REPO}"
            IMAGE_OVERRIDES="${IMAGE_OVERRIDES} --set backend-api.image.tag=${BACKEND_TAG}"
            IMAGE_OVERRIDES="${IMAGE_OVERRIDES} --set backend-ws.image.repository=${BACKEND_REPO}"
            IMAGE_OVERRIDES="${IMAGE_OVERRIDES} --set backend-ws.image.tag=${BACKEND_TAG}"
            IMAGE_OVERRIDES="${IMAGE_OVERRIDES} --set frontend.image.repository=${FRONTEND_REPO}"
            IMAGE_OVERRIDES="${IMAGE_OVERRIDES} --set frontend.image.tag=${FRONTEND_TAG}"
          fi

          echo "üöÄ Deploying Helm release..."
          echo "Release: ${{ inputs.client_name }}"
          echo "Namespace: ${{ inputs.client_name }}-${{ inputs.environment_type }}"
          
          helm upgrade --install ${{ inputs.client_name }} ./charts/jetscale \
            --namespace ${{ inputs.client_name }}-${{ inputs.environment_type }} \
            --create-namespace \
            $VALUES_FLAGS \
            $IMAGE_OVERRIDES \
            --wait \
            --timeout 10m \
            --atomic \
            --cleanup-on-fail
          
          echo "‚úÖ Deployment completed successfully"
