name: Manual Helm Deploy

on:
  workflow_dispatch:
    inputs:
      environment_type:
        description: 'Environment type (staging, live)'
        required: true
        default: staging
        type: choice
        options:
          - staging
          - live
      client_name:
        description: 'Client name (e.g., jetscale)'
        required: true
        default: jetscale
        type: string
      cloud_provider:
        description: 'Cloud provider'
        required: true
        type: choice
        default: 'aws'
        options:
          - aws
      aws_region:
        description: 'Client/Cluster AWS Region'
        required: true
        type: choice
        default: 'us-east-1'
        options:
          - us-east-1
          - us-west-2
          - eu-west-1
      build_images:
        description: 'Build new images from branch code'
        required: false
        type: boolean
        default: false
      backend_ref:
        description: 'Backend repo branch/tag (required if build_images=true)'
        required: false
        type: string
        default: 'main'
      frontend_ref:
        description: 'Frontend repo branch/tag (required if build_images=true)'
        required: false
        type: string
        default: 'main'

# Required for OIDC
permissions:
  id-token: write
  contents: read

jobs:
  # ============================================================================
  # BUILD IMAGES (Optional - only if build_images=true)
  # ============================================================================
  build-images:
    name: Build Images
    if: inputs.build_images == true
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment_type }}
    outputs:
      backend_tag: ${{ steps.build.outputs.backend_tag }}
      frontend_tag: ${{ steps.build.outputs.frontend_tag }}
    steps:
      - name: Configure AWS Credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v6
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/${{ inputs.client_name }}-${{ inputs.environment_type }}-github-diff-actions-role
          aws-region: ${{ inputs.aws_region }}
          role-session-name: github-actions-build-images

      - name: Login to ECR
        id: ecr-login
        uses: aws-actions/amazon-ecr-login@v2

      - name: Checkout Backend
        uses: actions/checkout@v6
        with:
          repository: Jetscale-ai/Backend
          ref: ${{ inputs.backend_ref }}
          token: ${{ secrets.JETSCALEBOT_GITHUB_TOKEN }}
          path: backend

      - name: Checkout Frontend
        uses: actions/checkout@v6
        with:
          repository: Jetscale-ai/Frontend
          ref: ${{ inputs.frontend_ref }}
          token: ${{ secrets.JETSCALEBOT_GITHUB_TOKEN }}
          path: frontend

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR (for base images)
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.JETSCALEBOT_GITHUB_TOKEN }}

      - name: Build and Push Images
        id: build
        env:
          ECR_REGISTRY: ${{ steps.ecr-login.outputs.registry }}
          CLIENT: ${{ inputs.client_name }}
          ENV_TYPE: ${{ inputs.environment_type }}
        run: |
          # Generate image tag
          TIMESTAMP=$(date -u +"%Y%m%d-%H%M%S")
          BACKEND_SHA=$(cd backend && git rev-parse --short HEAD)
          FRONTEND_SHA=$(cd frontend && git rev-parse --short HEAD)

          BACKEND_TAG="${ENV_TYPE}-${CLIENT}-${TIMESTAMP}-${BACKEND_SHA}"
          FRONTEND_TAG="${ENV_TYPE}-${CLIENT}-${TIMESTAMP}-${FRONTEND_SHA}"

          BACKEND_REPO="${ECR_REGISTRY}/${CLIENT}-${ENV_TYPE}-backend"
          FRONTEND_REPO="${ECR_REGISTRY}/${CLIENT}-${ENV_TYPE}-frontend"

          # Build backend with appropriate tags
          BACKEND_TAGS="-t ${BACKEND_REPO}:${BACKEND_TAG}"
          if [ "${{ inputs.backend_ref }}" == "main" ]; then
            BACKEND_TAGS="${BACKEND_TAGS} -t ${BACKEND_REPO}:latest"
            echo "üè∑Ô∏è  Backend will be tagged as :latest (main branch)"
          fi

          echo "üî® Building backend image: ${BACKEND_REPO}:${BACKEND_TAG}"
          docker buildx build \
            --platform linux/amd64 \
            --push \
            ${BACKEND_TAGS} \
            ./backend

          # Build frontend with appropriate tags
          FRONTEND_TAGS="-t ${FRONTEND_REPO}:${FRONTEND_TAG}"
          if [ "${{ inputs.frontend_ref }}" == "main" ]; then
            FRONTEND_TAGS="${FRONTEND_TAGS} -t ${FRONTEND_REPO}:latest"
            echo "üè∑Ô∏è  Frontend will be tagged as :latest (main branch)"
          fi

          echo "üî® Building frontend image: ${FRONTEND_REPO}:${FRONTEND_TAG}"
          docker buildx build \
            --platform linux/amd64 \
            --push \
            ${FRONTEND_TAGS} \
            ./frontend

          echo "backend_tag=${BACKEND_TAG}" >> $GITHUB_OUTPUT
          echo "frontend_tag=${FRONTEND_TAG}" >> $GITHUB_OUTPUT

          echo "‚úÖ Images built and pushed:"
          echo "  Backend:  ${BACKEND_REPO}:${BACKEND_TAG}"
          echo "  Frontend: ${FRONTEND_REPO}:${FRONTEND_TAG}"
      
  # ============================================================================
  # VALIDATE CONFIGURATION
  # ============================================================================
  validate:
    name: Validate Configuration
    runs-on: ubuntu-latest
    outputs:
      values_files: ${{ steps.build_values.outputs.files }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Build values file list
        id: build_values
        run: |
          # Build the list of values files based on the tiered structure
          # Order: base -> cloud provider -> environment defaults -> client-specific

          VALUES_FILES=""

          # 1. Cloud provider values (required)
          CLOUD_VALUES="envs/${{ inputs.cloud_provider }}.yaml"
          if [ ! -f "$CLOUD_VALUES" ]; then
            echo "‚ùå Cloud provider values file not found: $CLOUD_VALUES"
            exit 1
          fi
          VALUES_FILES="$CLOUD_VALUES"

          # 2. Environment defaults (optional)
          ENV_DEFAULTS="envs/${{ inputs.environment_type }}/default.yaml"
          if [ -f "$ENV_DEFAULTS" ]; then
            VALUES_FILES="$VALUES_FILES,$ENV_DEFAULTS"
          fi

          # 3. Client-specific values (required)
          CLIENT_VALUES="envs/${{ inputs.environment_type }}/${{ inputs.client_name }}.yaml"
          if [ ! -f "$CLIENT_VALUES" ]; then
            echo "‚ùå Client values file not found: $CLIENT_VALUES"
            exit 1
          fi
          VALUES_FILES="$VALUES_FILES,$CLIENT_VALUES"

          echo "files=$VALUES_FILES" >> $GITHUB_OUTPUT

          echo "‚úÖ Values files to be applied (in order):"
          echo "$VALUES_FILES" | tr ',' '\n' | sed 's/^/  - /'

  helm-diff:
    name: Helm Diff
    needs: [validate, build-images]
    # Always run after validate succeeds, even if build-images was skipped
    if: always() && needs.validate.result == 'success'
    runs-on: ubuntu-latest
    # Use GitHub environment-type for seeing the diff (read-only role)
    environment: ${{ inputs.environment_type }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Configure AWS Credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v6
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/${{ inputs.client_name }}-${{ inputs.environment_type }}-github-diff-actions-role
          aws-region: ${{ inputs.aws_region }}
          role-session-name: github-actions-helm-diff

      - name: Setup Helm
        uses: azure/setup-helm@v6
        with:
          version: 'v3.18.3'

      - name: Install Helm Diff Plugin
        run: |
          helm plugin install https://github.com/databus23/helm-diff || true
          helm plugin list

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig \
            --region ${{ inputs.aws_region }} \
            --name ${{ inputs.client_name }}-${{ inputs.environment_type }}

          # Verify connection
          kubectl cluster-info
          kubectl get nodes

      - name: Login to GHCR (Helm)
        env:
          BOT_TOKEN: ${{ secrets.JETSCALEBOT_GITHUB_TOKEN }}
        run: |
          echo "$BOT_TOKEN" | helm registry login ghcr.io --username jetscalebot --password-stdin

      - name: Update Helm Dependencies
        run: |
          cd charts/jetscale
          helm dependency update

      - name: Run Helm Diff
        id: helm_diff
        env:
          BUILD_IMAGES: ${{ inputs.build_images }}
          BACKEND_TAG: ${{ needs.build-images.outputs.backend_tag }}
          FRONTEND_TAG: ${{ needs.build-images.outputs.frontend_tag }}
        run: |
          # Build values flags from comma-separated list
          VALUES_FLAGS=""
          IFS=',' read -ra FILES <<< "${{ needs.validate.outputs.values_files }}"
          for file in "${FILES[@]}"; do
            VALUES_FLAGS="$VALUES_FLAGS --values $file"
          done

          # Check if Helm release is installed
          RELEASE_EXISTS=false
          if helm list -n ${{ inputs.client_name }} | grep -q "^${{ inputs.client_name }}\s"; then
            RELEASE_EXISTS=true
            echo "üì¶ Helm release '${{ inputs.client_name }}' is already installed"
          else
            echo "üì¶ Helm release '${{ inputs.client_name }}' is NOT installed"
          fi

          # Add image tag overrides
          IMAGE_OVERRIDES=""
          if [ "${BUILD_IMAGES}" == "true" ] && [ -n "${BACKEND_TAG}" ] && [ -n "${FRONTEND_TAG}" ]; then
            # Use newly built image tags
            echo "üì¶ Using newly built image tags: backend=${BACKEND_TAG} frontend=${FRONTEND_TAG}"
            IMAGE_OVERRIDES="--set backend-api.image.tag=${BACKEND_TAG} --set backend-ws.image.tag=${BACKEND_TAG} --set frontend.image.tag=${FRONTEND_TAG}"
          elif [ "${RELEASE_EXISTS}" == "true" ]; then
            # Release exists, get current deployed image tags
            echo "üì¶ Getting current deployed image tags from existing release..."
            CURRENT_BACKEND_TAG=$(helm get values ${{ inputs.client_name }} -n ${{ inputs.client_name }} -o json | jq -r '."backend-api".image.tag // empty')
            CURRENT_FRONTEND_TAG=$(helm get values ${{ inputs.client_name }} -n ${{ inputs.client_name }} -o json | jq -r '.frontend.image.tag // empty')
            
            if [ -n "${CURRENT_BACKEND_TAG}" ] && [ -n "${CURRENT_FRONTEND_TAG}" ]; then
              echo "üì¶ Using current deployed tags: backend=${CURRENT_BACKEND_TAG} frontend=${CURRENT_FRONTEND_TAG}"
              IMAGE_OVERRIDES="--set backend-api.image.tag=${CURRENT_BACKEND_TAG} --set backend-ws.image.tag=${CURRENT_BACKEND_TAG} --set frontend.image.tag=${CURRENT_FRONTEND_TAG}"
            else
              echo "‚ö†Ô∏è Could not retrieve current image tags, using :latest as fallback"
              IMAGE_OVERRIDES="--set backend-api.image.tag=latest --set backend-ws.image.tag=latest --set frontend.image.tag=latest"
            fi
          else
            # Release not installed, use :latest tags
            echo "üì¶ Using :latest tags for initial installation"
            IMAGE_OVERRIDES="--set backend-api.image.tag=latest --set backend-ws.image.tag=latest --set frontend.image.tag=latest"
          fi

          echo "üìä Running Helm diff..."
          echo "Release: ${{ inputs.client_name }}"
          echo "Namespace: ${{ inputs.client_name }}"
          echo "Values files: ${{ needs.validate.outputs.values_files }}"

          # Run diff and capture output
          set +e
          helm diff upgrade ${{ inputs.client_name }} ./charts/jetscale \
            --namespace ${{ inputs.client_name }} \
            --allow-unreleased \
            $VALUES_FLAGS \
            $IMAGE_OVERRIDES \
            --context 5 \
            --color
          DIFF_EXIT_CODE=$?
          set -e

          # Check if there are changes
          if [ $DIFF_EXIT_CODE -eq 0 ]; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "üìã No changes detected"
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "üìã Changes detected"
          fi

      - name: Check for changes
        if: steps.helm_diff.outputs.has_changes == 'false'
        run: |
          echo "‚ö†Ô∏è No changes detected. Deployment would be a no-op."
          echo "If you expected changes, verify your values files."

  helm-deploy:
    name: Helm Deploy
    needs: [validate, helm-diff, build-images]
    # Always run, but build-images may be skipped
    if: always() && needs.validate.result == 'success' && needs.helm-diff.result == 'success'
    runs-on: ubuntu-latest
    # Use GitHub environment for manual approval (staging has required reviewers configured).
    environment: ${{ inputs.environment_type }}-${{ inputs.client_name }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Configure AWS Credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v6
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/${{ inputs.client_name }}-${{ inputs.environment_type }}-github-actions-role
          aws-region: ${{ inputs.aws_region }}
          role-session-name: github-actions-helm-deploy

      - name: Setup Helm
        uses: azure/setup-helm@v6
        with:
          version: 'v3.18.3'

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig \
            --region ${{ inputs.aws_region }} \
            --name ${{ inputs.client_name }}-${{ inputs.environment_type }}

          # Verify connection
          kubectl cluster-info

      - name: Login to GHCR (Helm)
        env:
          BOT_TOKEN: ${{ secrets.JETSCALEBOT_GITHUB_TOKEN }}
        run: |
          echo "$BOT_TOKEN" | helm registry login ghcr.io --username jetscalebot --password-stdin

      - name: Update Helm Dependencies
        run: |
          cd charts/jetscale
          helm dependency update

      - name: Deploy with Helm
        env:
          BUILD_IMAGES: ${{ inputs.build_images }}
          BACKEND_TAG: ${{ needs.build-images.outputs.backend_tag }}
          FRONTEND_TAG: ${{ needs.build-images.outputs.frontend_tag }}
        run: |
          # Build values flags from comma-separated list
          VALUES_FLAGS=""
          IFS=',' read -ra FILES <<< "${{ needs.validate.outputs.values_files }}"
          for file in "${FILES[@]}"; do
            VALUES_FLAGS="$VALUES_FLAGS --values $file"
          done

          # Check if Helm release is installed
          RELEASE_EXISTS=false
          if helm list -n ${{ inputs.client_name }} | grep -q "^${{ inputs.client_name }}\s"; then
            RELEASE_EXISTS=true
            echo "üì¶ Helm release '${{ inputs.client_name }}' is already installed"
          else
            echo "üì¶ Helm release '${{ inputs.client_name }}' is NOT installed"
          fi

          # Add image tag overrides
          IMAGE_OVERRIDES=""
          if [ "${BUILD_IMAGES}" == "true" ] && [ -n "${BACKEND_TAG}" ] && [ -n "${FRONTEND_TAG}" ]; then
            # Use newly built image tags
            echo "üì¶ Using newly built image tags: backend=${BACKEND_TAG} frontend=${FRONTEND_TAG}"
            IMAGE_OVERRIDES="--set backend-api.image.tag=${BACKEND_TAG} --set backend-ws.image.tag=${BACKEND_TAG} --set frontend.image.tag=${FRONTEND_TAG}"
          elif [ "${RELEASE_EXISTS}" == "true" ]; then
            # Release exists, get current deployed image tags
            echo "üì¶ Getting current deployed image tags from existing release..."
            CURRENT_BACKEND_TAG=$(helm get values ${{ inputs.client_name }} -n ${{ inputs.client_name }} -o json | jq -r '."backend-api".image.tag // empty')
            CURRENT_FRONTEND_TAG=$(helm get values ${{ inputs.client_name }} -n ${{ inputs.client_name }} -o json | jq -r '.frontend.image.tag // empty')
            
            if [ -n "${CURRENT_BACKEND_TAG}" ] && [ -n "${CURRENT_FRONTEND_TAG}" ]; then
              echo "üì¶ Using current deployed tags: backend=${CURRENT_BACKEND_TAG} frontend=${CURRENT_FRONTEND_TAG}"
              IMAGE_OVERRIDES="--set backend-api.image.tag=${CURRENT_BACKEND_TAG} --set backend-ws.image.tag=${CURRENT_BACKEND_TAG} --set frontend.image.tag=${CURRENT_FRONTEND_TAG}"
            else
              echo "‚ö†Ô∏è Could not retrieve current image tags, using :latest as fallback"
              IMAGE_OVERRIDES="--set backend-api.image.tag=latest --set backend-ws.image.tag=latest --set frontend.image.tag=latest"
            fi
          else
            # Release not installed, use :latest tags
            echo "üì¶ Using :latest tags for initial installation"
            IMAGE_OVERRIDES="--set backend-api.image.tag=latest --set backend-ws.image.tag=latest --set frontend.image.tag=latest"
          fi

          echo "üöÄ Deploying Helm release..."
          echo "Release: ${{ inputs.client_name }}"
          echo "Namespace: ${{ inputs.client_name }}"

          helm upgrade --install ${{ inputs.client_name }} ./charts/jetscale \
            --namespace ${{ inputs.client_name }} \
            $VALUES_FLAGS \
            $IMAGE_OVERRIDES \
            --wait \
            --timeout 10m

          echo "‚úÖ Deployment completed successfully"
